<!DOCTYPE html>
<html lang="zh-CN">
<head>
 <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script> 
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学习JavaScript权威指南第四天第九章 类和模块1.类的特性有封装、继承和多态。2.构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。3.初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。4.在JavaScript中定义类的步骤可以缩减为一个分三步的算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="学习JavaScript权威指南第四天">
<meta property="og:url" content="http://yoursite.com/2021/02/26/JavaScriptfour/index.html">
<meta property="og:site_name" content="DKの博客">
<meta property="og:description" content="学习JavaScript权威指南第四天第九章 类和模块1.类的特性有封装、继承和多态。2.构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。3.初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。4.在JavaScript中定义类的步骤可以缩减为一个分三步的算法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-26T11:10:50.000Z">
<meta property="article:modified_time" content="2021-02-26T15:31:53.348Z">
<meta property="article:author" content="丁可">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/02/26/JavaScriptfour/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>学习JavaScript权威指南第四天 | DKの博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/DK-frontend" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DKの博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录前端学习的历程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">37</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/JavaScriptfour/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="丁可">
      <meta itemprop="description" content="哪来的勇气我就是不灰心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DKの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习JavaScript权威指南第四天
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-26 19:10:50 / 修改时间：23:31:53" itemprop="dateCreated datePublished" datetime="2021-02-26T19:10:50+08:00">2021-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="学习JavaScript权威指南第四天"><a href="#学习JavaScript权威指南第四天" class="headerlink" title="学习JavaScript权威指南第四天"></a>学习JavaScript权威指南第四天</h1><h2 id="第九章-类和模块"><a href="#第九章-类和模块" class="headerlink" title="第九章 类和模块"></a>第九章 类和模块</h2><h3 id="1-类的特性有封装、继承和多态。"><a href="#1-类的特性有封装、继承和多态。" class="headerlink" title="1.类的特性有封装、继承和多态。"></a>1.类的特性有封装、继承和多态。</h3><h3 id="2-构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。"><a href="#2-构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。" class="headerlink" title="2.构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。"></a>2.构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。</h3><h3 id="3-初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。"><a href="#3-初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。" class="headerlink" title="3.初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。"></a>3.初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。</h3><h3 id="4-在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。"><a href="#4-在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。" class="headerlink" title="4.在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。"></a>4.在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。</h3><h3 id="5-JavaScript中基于原型的继承机制是动态的-对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象。"><a href="#5-JavaScript中基于原型的继承机制是动态的-对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象。" class="headerlink" title="5.JavaScript中基于原型的继承机制是动态的:对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象。"></a>5.JavaScript中基于原型的继承机制是动态的:对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象。</h3><h3 id="6-instanceof运算符和isPrototypeOf-方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的Web应用中兼容性不佳。"><a href="#6-instanceof运算符和isPrototypeOf-方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的Web应用中兼容性不佳。" class="headerlink" title="6.instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的Web应用中兼容性不佳。"></a>6.instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的Web应用中兼容性不佳。</h3><h3 id="7-使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法工作的-比如在浏览器窗口的多个框架子页面中-。同样，在JavaScript中也并非所有的对象都包含constructor属性。"><a href="#7-使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法工作的-比如在浏览器窗口的多个框架子页面中-。同样，在JavaScript中也并非所有的对象都包含constructor属性。" class="headerlink" title="7.使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法工作的(比如在浏览器窗口的多个框架子页面中)。同样，在JavaScript中也并非所有的对象都包含constructor属性。"></a>7.使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法工作的(比如在浏览器窗口的多个框架子页面中)。同样，在JavaScript中也并非所有的对象都包含constructor属性。</h3><h3 id="8-一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些JavaScript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的JavaScript实现来说，可以将函数转换为字符串，然后从中提取出函数名。这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题-并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。"><a href="#8-一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些JavaScript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的JavaScript实现来说，可以将函数转换为字符串，然后从中提取出函数名。这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题-并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。" class="headerlink" title="8.一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些JavaScript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的JavaScript实现来说，可以将函数转换为字符串，然后从中提取出函数名。这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题:并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。"></a>8.一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些JavaScript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的JavaScript实现来说，可以将函数转换为字符串，然后从中提取出函数名。这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题:并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。</h3><a id="more"></a>
<h3 id="9-按照鸭式辩型的理念定义了quacks-函数。quacks-用以检查一个对象-第一个实参-是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。关于quacks-函数还有另一个问题需要注意，就是它不能应用于内置类。比如，不能通过quacks-o，Array-来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks-中的for-in循环无法遍历到它们-注意，在ECMAScript-5中有一个补救办法，就是使用Object-getOwnPropertyName"><a href="#9-按照鸭式辩型的理念定义了quacks-函数。quacks-用以检查一个对象-第一个实参-是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。关于quacks-函数还有另一个问题需要注意，就是它不能应用于内置类。比如，不能通过quacks-o，Array-来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks-中的for-in循环无法遍历到它们-注意，在ECMAScript-5中有一个补救办法，就是使用Object-getOwnPropertyName" class="headerlink" title="9.按照鸭式辩型的理念定义了quacks()函数。quacks()用以检查一个对象(第一个实参)是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。关于quacks()函数还有另一个问题需要注意，就是它不能应用于内置类。比如，不能通过quacks(o，Array)来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks()中的for/in循环无法遍历到它们(注意，在ECMAScript 5中有一个补救办法，就是使用Object.getOwnPropertyName())"></a>9.按照鸭式辩型的理念定义了quacks()函数。quacks()用以检查一个对象(第一个实参)是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。关于quacks()函数还有另一个问题需要注意，就是它不能应用于内置类。比如，不能通过quacks(o，Array)来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks()中的for/in循环无法遍历到它们(注意，在ECMAScript 5中有一个补救办法，就是使用Object.getOwnPropertyName())</h3><h3 id="10-JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等。或者比较它们的顺序。这里所说的”相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。如果将对象用于JavaScript的关系比较运算符，比如”-lt-”和”-lt-”，JavaScript会首先调用对象的valueOf-，如果这个方法返回一个原始值，则直接比较原始值。"><a href="#10-JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等。或者比较它们的顺序。这里所说的”相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。如果将对象用于JavaScript的关系比较运算符，比如”-lt-”和”-lt-”，JavaScript会首先调用对象的valueOf-，如果这个方法返回一个原始值，则直接比较原始值。" class="headerlink" title="10.JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等。或者比较它们的顺序。这里所说的”相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。如果将对象用于JavaScript的关系比较运算符，比如”&lt;”和”&lt;=”，JavaScript会首先调用对象的valueOf()，如果这个方法返回一个原始值，则直接比较原始值。"></a>10.JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等。或者比较它们的顺序。这里所说的”相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。如果将对象用于JavaScript的关系比较运算符，比如”&lt;”和”&lt;=”，JavaScript会首先调用对象的valueOf()，如果这个方法返回一个原始值，则直接比较原始值。</h3><h3 id="11-我们可以通过将变量-或参数-闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数-因此这个函数可以访问构造函数内部的参数和变量-，并将这个函数赋值给新创建对象的属性。但需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢。"><a href="#11-我们可以通过将变量-或参数-闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数-因此这个函数可以访问构造函数内部的参数和变量-，并将这个函数赋值给新创建对象的属性。但需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢。" class="headerlink" title="11.我们可以通过将变量(或参数)闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数(因此这个函数可以访问构造函数内部的参数和变量)，并将这个函数赋值给新创建对象的属性。但需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢。"></a>11.我们可以通过将变量(或参数)闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数(因此这个函数可以访问构造函数内部的参数和变量)，并将这个函数赋值给新创建对象的属性。但需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢。</h3><h3 id="12-通过重载构造函数可以让它根据传入参数的不同来执行不同的初始化方法。"><a href="#12-通过重载构造函数可以让它根据传入参数的不同来执行不同的初始化方法。" class="headerlink" title="12.通过重载构造函数可以让它根据传入参数的不同来执行不同的初始化方法。"></a>12.通过重载构造函数可以让它根据传入参数的不同来执行不同的初始化方法。</h3><h3 id="13-Object-defineProperty-和Object-defineProperties-可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。"><a href="#13-Object-defineProperty-和Object-defineProperties-可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。" class="headerlink" title="13.Object.defineProperty()和Object.defineProperties()可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。"></a>13.Object.defineProperty()和Object.defineProperties()可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。</h3><h3 id="14-使用Object-create-创建对象时传入了参数null，这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用in运算符，而不须使用hasOwnProperty-方法。"><a href="#14-使用Object-create-创建对象时传入了参数null，这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用in运算符，而不须使用hasOwnProperty-方法。" class="headerlink" title="14.使用Object.create()创建对象时传入了参数null，这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用in运算符，而不须使用hasOwnProperty()方法。"></a>14.使用Object.create()创建对象时传入了参数null，这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用in运算符，而不须使用hasOwnProperty()方法。</h3><h3 id="15-在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来-可以通过全局变量引用-，而不是定义全局函数和变量。"><a href="#15-在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来-可以通过全局变量引用-，而不是定义全局函数和变量。" class="headerlink" title="15.在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来(可以通过全局变量引用)，而不是定义全局函数和变量。"></a>15.在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来(可以通过全局变量引用)，而不是定义全局函数和变量。</h3><h2 id="第十章-正则表达式的模式匹配"><a href="#第十章-正则表达式的模式匹配" class="headerlink" title="第十章 正则表达式的模式匹配"></a>第十章 正则表达式的模式匹配</h2><h3 id="1-一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript-5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。"><a href="#1-一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript-5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。" class="headerlink" title="1.一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。"></a>1.一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。</h3><h3 id="2-将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。另外，可以通过”-”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。"><a href="#2-将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。另外，可以通过”-”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。" class="headerlink" title="2.将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。另外，可以通过”^”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。"></a>2.将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。另外，可以通过”^”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。</h3><h3 id="3-匹配重复字符是尽可能多地匹配，而且允许后续地正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在待匹配的字符后跟随一个问好即可。因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。"><a href="#3-匹配重复字符是尽可能多地匹配，而且允许后续地正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在待匹配的字符后跟随一个问好即可。因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。" class="headerlink" title="3.匹配重复字符是尽可能多地匹配，而且允许后续地正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在待匹配的字符后跟随一个问好即可。因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。"></a>3.匹配重复字符是尽可能多地匹配，而且允许后续地正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在待匹配的字符后跟随一个问好即可。因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。</h3><h3 id="4-注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用”-””-””-”或者”-”等来对单元内的项进行处理。圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。正则表达式不允许使用双引号括起的内容中有单引号，反之亦然。"><a href="#4-注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用”-””-””-”或者”-”等来对单元内的项进行处理。圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。正则表达式不允许使用双引号括起的内容中有单引号，反之亦然。" class="headerlink" title="4.注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用”|””*””+”或者”?”等来对单元内的项进行处理。圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。正则表达式不允许使用双引号括起的内容中有单引号，反之亦然。"></a>4.注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用”|””*””+”或者”?”等来对单元内的项进行处理。圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。正则表达式不允许使用双引号括起的内容中有单引号，反之亦然。</h3><h3 id="5-正则表达式中的多个元素才能够匹配字符串的一个字符。还有一些正则表达式的元素匹配的是字符串之间的位置，而不是实际的字符。-b匹配一个单词的边界，像-b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是-，它用来匹配字符串的开始，锚元素-用以匹配字符串的结束。"><a href="#5-正则表达式中的多个元素才能够匹配字符串的一个字符。还有一些正则表达式的元素匹配的是字符串之间的位置，而不是实际的字符。-b匹配一个单词的边界，像-b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是-，它用来匹配字符串的开始，锚元素-用以匹配字符串的结束。" class="headerlink" title="5.正则表达式中的多个元素才能够匹配字符串的一个字符。还有一些正则表达式的元素匹配的是字符串之间的位置，而不是实际的字符。\b匹配一个单词的边界，像\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。"></a>5.正则表达式中的多个元素才能够匹配字符串的一个字符。还有一些正则表达式的元素匹配的是字符串之间的位置，而不是实际的字符。\b匹配一个单词的边界，像\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。</h3><h3 id="6-String支持4种使用正则表达式的方法。"><a href="#6-String支持4种使用正则表达式的方法。" class="headerlink" title="6.String支持4种使用正则表达式的方法。"></a>6.String支持4种使用正则表达式的方法。</h3><ul>
<li>最简单的search()。它的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到匹配的子串，它将返回-1.如果search()的参数不是正则表达式，则首先会通过RegExp构造函数将它转换成正则表达式，search()方法不支持全局搜索，因为它忽略正则表达式参数中的修饰符g。</li>
<li>replace()方法用以执行检索与替换操作。其中第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。这个方法会对调用它的字符串进行检索，使用指定的模式来匹配。如果正则表达式中设置了修饰符g，那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串；如果不带修饰符g，则只替换所匹配的第一个子串。如果replace()的第一个参数是字符串而不是正则表达式，则replace()将直接搜索这个字符串，而不是像search()一样首先通过RegExp()将它转换为正则表达式。如果在替换字符串中出现了$加数字，那么replace()将用与指定的子表达式相匹配的文本来替换这两个字符。</li>
<li>match()方法是最常用的String正则表达式方法。它的唯一参数就是一个正则表达式(或通过RegExp()构造函数将其转换为正则表达式)，返回的是一个由匹配结果组成的数组。如果该正则表达式设置了修饰符g，则该方法返回的数组包含字符串中的所有匹配结果。如果这个正则表达式没有设置修饰符g，match()就不会进行全局搜索，它只检索第一个匹配。但即使match()执行的不是全局搜索，它也返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。</li>
<li>String对象的最后一个和正则表达式相关的方法是split()。这个方法用以将调用它的字符串拆分为一个子串组成的数组，使用的分隔符是split()的参数。</li>
</ul>
<h3 id="7-需要注意的是，不论是字符串直接量还是正则表达式，都使用”-quot-字符作为转义字符的前缀，因此当给RegExp-传入一个字符串表述的正则表达式时，必须将”-quot-替换成”-“。RegExp-构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。"><a href="#7-需要注意的是，不论是字符串直接量还是正则表达式，都使用”-quot-字符作为转义字符的前缀，因此当给RegExp-传入一个字符串表述的正则表达式时，必须将”-quot-替换成”-“。RegExp-构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。" class="headerlink" title="7.需要注意的是，不论是字符串直接量还是正则表达式，都使用”&quot;字符作为转义字符的前缀，因此当给RegExp()传入一个字符串表述的正则表达式时，必须将”&quot;替换成”\“。RegExp()构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。"></a>7.需要注意的是，不论是字符串直接量还是正则表达式，都使用”&quot;字符作为转义字符的前缀，因此当给RegExp()传入一个字符串表述的正则表达式时，必须将”&quot;替换成”\“。RegExp()构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。</h3><h3 id="8-每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读-写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置。"><a href="#8-每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读-写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置。" class="headerlink" title="8.每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置。"></a>8.每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置。</h3><h3 id="9-RegExp对象定义了两个用于执行模式匹配操作的方法。"><a href="#9-RegExp对象定义了两个用于执行模式匹配操作的方法。" class="headerlink" title="9.RegExp对象定义了两个用于执行模式匹配操作的方法。"></a>9.RegExp对象定义了两个用于执行模式匹配操作的方法。</h3><ul>
<li>exec()方法对一个指定的字符串执行一个正则表达式，简言之，就是在一个字符串中执行匹配搜索。如果它没有找到任何匹配，它就返回null，但如果它找到了一个匹配，它将返回一个数组，就像match()方法为非全局检索返回的数组一样。属性index包含了发生匹配的字符位置，属性input引用的是正在检索的字符串。</li>
<li>另外一个RegExp方法是test()，它比exec()更简单一些。它的参数是一个字符串，用rest()对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回true。如果让一个带有修饰符g的正则表达式对多个字符串执行exec()或test()，要么在每个字符串中找出所有的匹配以便将lastIndex自动重置为零，要么显式将lastIndex手动设置为0(当最后一次检索失败时需要手动设置lastIndex)。如果忘了手动设置lastIndex的值，那么下一次对新字符串进行检索时，执行检索的起始位置可能就不是字符串的开始位置，而可能是任意位置。</li>
</ul>
<h3 id="10-在ECMAScript-5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新的RegExp对象具有各自的lastIndex属性，这势必会大大减少”残留”lastIndex对程序造成的意外影响。"><a href="#10-在ECMAScript-5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新的RegExp对象具有各自的lastIndex属性，这势必会大大减少”残留”lastIndex对程序造成的意外影响。" class="headerlink" title="10.在ECMAScript 5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新的RegExp对象具有各自的lastIndex属性，这势必会大大减少”残留”lastIndex对程序造成的意外影响。"></a>10.在ECMAScript 5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新的RegExp对象具有各自的lastIndex属性，这势必会大大减少”残留”lastIndex对程序造成的意外影响。</h3><h2 id="第十一章-JavaScript的子集和扩展"><a href="#第十一章-JavaScript的子集和扩展" class="headerlink" title="第十一章 JavaScript的子集和扩展"></a>第十一章 JavaScript的子集和扩展</h2><h3 id="1-大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。"><a href="#1-大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。" class="headerlink" title="1.大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。"></a>1.大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。</h3><h3 id="2-解构赋值右侧的数组所包含的元素不必和左侧的变量一一对应，左侧多余的变量的赋值为undefined，而右侧多余的值则会忽略。左侧的变量列表可以包含连续的逗号用以跳过右侧对应的值。整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。因此，可以这样写”链式”解构赋值。"><a href="#2-解构赋值右侧的数组所包含的元素不必和左侧的变量一一对应，左侧多余的变量的赋值为undefined，而右侧多余的值则会忽略。左侧的变量列表可以包含连续的逗号用以跳过右侧对应的值。整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。因此，可以这样写”链式”解构赋值。" class="headerlink" title="2.解构赋值右侧的数组所包含的元素不必和左侧的变量一一对应，左侧多余的变量的赋值为undefined，而右侧多余的值则会忽略。左侧的变量列表可以包含连续的逗号用以跳过右侧对应的值。整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。因此，可以这样写”链式”解构赋值。"></a>2.解构赋值右侧的数组所包含的元素不必和左侧的变量一一对应，左侧多余的变量的赋值为undefined，而右侧多余的值则会忽略。左侧的变量列表可以包含连续的逗号用以跳过右侧对应的值。整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。因此，可以这样写”链式”解构赋值。</h3><h3 id="3-for-each循环和for-in循环非常类似。但for-each并不是遍历对象的属性，而是遍历属性的值。注意，for-each循环并不仅仅针对数组本身的元素进行遍历，它也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。"><a href="#3-for-each循环和for-in循环非常类似。但for-each并不是遍历对象的属性，而是遍历属性的值。注意，for-each循环并不仅仅针对数组本身的元素进行遍历，它也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。" class="headerlink" title="3.for/each循环和for/in循环非常类似。但for/each并不是遍历对象的属性，而是遍历属性的值。注意，for/each循环并不仅仅针对数组本身的元素进行遍历，它也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。"></a>3.for/each循环和for/in循环非常类似。但for/each并不是遍历对象的属性，而是遍历属性的值。注意，for/each循环并不仅仅针对数组本身的元素进行遍历，它也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。</h3><h3 id="4-如果出于某种考虑，你想从可迭代的对象中显式获得一个迭代器对象。只需调用Iterator-函数即可-这个函数是定义在JavaScript1-7中的全局函数-。如果这个函数的参数是一个可迭代的对象，那么它将返回这个对象的iterator-方法的调用结果，从而保持代码整洁干净。如果给Iterator-函数传入第二个参数，这个参数也会参与iterator-方法的调用。"><a href="#4-如果出于某种考虑，你想从可迭代的对象中显式获得一个迭代器对象。只需调用Iterator-函数即可-这个函数是定义在JavaScript1-7中的全局函数-。如果这个函数的参数是一个可迭代的对象，那么它将返回这个对象的iterator-方法的调用结果，从而保持代码整洁干净。如果给Iterator-函数传入第二个参数，这个参数也会参与iterator-方法的调用。" class="headerlink" title="4.如果出于某种考虑，你想从可迭代的对象中显式获得一个迭代器对象。只需调用Iterator()函数即可(这个函数是定义在JavaScript1.7中的全局函数)。如果这个函数的参数是一个可迭代的对象，那么它将返回这个对象的iterator()方法的调用结果，从而保持代码整洁干净。如果给Iterator()函数传入第二个参数，这个参数也会参与iterator()方法的调用。"></a>4.如果出于某种考虑，你想从可迭代的对象中显式获得一个迭代器对象。只需调用Iterator()函数即可(这个函数是定义在JavaScript1.7中的全局函数)。如果这个函数的参数是一个可迭代的对象，那么它将返回这个对象的<em>iterator</em>()方法的调用结果，从而保持代码整洁干净。如果给Iterator()函数传入第二个参数，这个参数也会参与<em>iterator</em>()方法的调用。</h3><h3 id="5-Iterator-函数返回的迭代器还有两个重要的特性。第一，它只对自有属性进行遍历而忽略继承的属性，通常我们希望是这个样子。第二，如果给Iterator-传入第二个参数true，返回的迭代器只对属性名进行遍历，而忽略属性值。"><a href="#5-Iterator-函数返回的迭代器还有两个重要的特性。第一，它只对自有属性进行遍历而忽略继承的属性，通常我们希望是这个样子。第二，如果给Iterator-传入第二个参数true，返回的迭代器只对属性名进行遍历，而忽略属性值。" class="headerlink" title="5.Iterator()函数返回的迭代器还有两个重要的特性。第一，它只对自有属性进行遍历而忽略继承的属性，通常我们希望是这个样子。第二，如果给Iterator()传入第二个参数true，返回的迭代器只对属性名进行遍历，而忽略属性值。"></a>5.Iterator()函数返回的迭代器还有两个重要的特性。第一，它只对自有属性进行遍历而忽略继承的属性，通常我们希望是这个样子。第二，如果给Iterator()传入第二个参数true，返回的迭代器只对属性名进行遍历，而忽略属性值。</h3><h3 id="6-生成器函数通过yield返回值。这些函数中可以使用return来终止函数的执行而不带任何返回值，但不能使用return来返回一个值。除了使用yield，对return的使用限制也使生成器函数更明显地区别于普通函数。然而和普通的函数一样，生成器函数也通过关键字function声明，typeof运算符返回”function”，并可以从Function-prototype继承属性和方法。但对生成器函数的调用却和普通函数完全不一样，不是执行生成器函数的函数体，而是返回一个生成器对象。"><a href="#6-生成器函数通过yield返回值。这些函数中可以使用return来终止函数的执行而不带任何返回值，但不能使用return来返回一个值。除了使用yield，对return的使用限制也使生成器函数更明显地区别于普通函数。然而和普通的函数一样，生成器函数也通过关键字function声明，typeof运算符返回”function”，并可以从Function-prototype继承属性和方法。但对生成器函数的调用却和普通函数完全不一样，不是执行生成器函数的函数体，而是返回一个生成器对象。" class="headerlink" title="6.生成器函数通过yield返回值。这些函数中可以使用return来终止函数的执行而不带任何返回值，但不能使用return来返回一个值。除了使用yield，对return的使用限制也使生成器函数更明显地区别于普通函数。然而和普通的函数一样，生成器函数也通过关键字function声明，typeof运算符返回”function”，并可以从Function.prototype继承属性和方法。但对生成器函数的调用却和普通函数完全不一样，不是执行生成器函数的函数体，而是返回一个生成器对象。"></a>6.生成器函数通过yield返回值。这些函数中可以使用return来终止函数的执行而不带任何返回值，但不能使用return来返回一个值。除了使用yield，对return的使用限制也使生成器函数更明显地区别于普通函数。然而和普通的函数一样，生成器函数也通过关键字function声明，typeof运算符返回”function”，并可以从Function.prototype继承属性和方法。但对生成器函数的调用却和普通函数完全不一样，不是执行生成器函数的函数体，而是返回一个生成器对象。</h3><h3 id="7-当调用了生成器的close-方法时，和它相关的生成器函数就会终止执行，就像在函数运行挂起的位置执行一条return语句。如果当前挂起位置在一个或者多个try语句块中，那么将首先运行finally从句，再执行close-返回。close-没有返回值，但如果finally语句块产生了异常，这个异常则会传播给close-。"><a href="#7-当调用了生成器的close-方法时，和它相关的生成器函数就会终止执行，就像在函数运行挂起的位置执行一条return语句。如果当前挂起位置在一个或者多个try语句块中，那么将首先运行finally从句，再执行close-返回。close-没有返回值，但如果finally语句块产生了异常，这个异常则会传播给close-。" class="headerlink" title="7.当调用了生成器的close()方法时，和它相关的生成器函数就会终止执行，就像在函数运行挂起的位置执行一条return语句。如果当前挂起位置在一个或者多个try语句块中，那么将首先运行finally从句，再执行close()返回。close()没有返回值，但如果finally语句块产生了异常，这个异常则会传播给close()。"></a>7.当调用了生成器的close()方法时，和它相关的生成器函数就会终止执行，就像在函数运行挂起的位置执行一条return语句。如果当前挂起位置在一个或者多个try语句块中，那么将首先运行finally从句，再执行close()返回。close()没有返回值，但如果finally语句块产生了异常，这个异常则会传播给close()。</h3><h3 id="8-每一个生成器都有一个send-方法，后者用来重启生成器的执行，就像next-方法一样。和next-不同的是，send-可以带一个参数，这个参数的值就成为yield表达式的值-多数生成器函数是不会接收额外的输入的，关键字yield看起来像一条语句。"><a href="#8-每一个生成器都有一个send-方法，后者用来重启生成器的执行，就像next-方法一样。和next-不同的是，send-可以带一个参数，这个参数的值就成为yield表达式的值-多数生成器函数是不会接收额外的输入的，关键字yield看起来像一条语句。" class="headerlink" title="8.每一个生成器都有一个send()方法，后者用来重启生成器的执行，就像next()方法一样。和next()不同的是，send()可以带一个参数，这个参数的值就成为yield表达式的值(多数生成器函数是不会接收额外的输入的，关键字yield看起来像一条语句。"></a>8.每一个生成器都有一个send()方法，后者用来重启生成器的执行，就像next()方法一样。和next()不同的是，send()可以带一个参数，这个参数的值就成为yield表达式的值(多数生成器函数是不会接收额外的输入的，关键字yield看起来像一条语句。</h3><h3 id="9-数组推导是从Python中借用过来的一个概念。它是一种利用另外一个数组或可迭代对象来初始化数组元素的技术。数组推导包含三个部分"><a href="#9-数组推导是从Python中借用过来的一个概念。它是一种利用另外一个数组或可迭代对象来初始化数组元素的技术。数组推导包含三个部分" class="headerlink" title="9.数组推导是从Python中借用过来的一个概念。它是一种利用另外一个数组或可迭代对象来初始化数组元素的技术。数组推导包含三个部分:"></a>9.数组推导是从Python中借用过来的一个概念。它是一种利用另外一个数组或可迭代对象来初始化数组元素的技术。数组推导包含三个部分:</h3><ul>
<li>一个没有循环体的for/in或for/each循环</li>
<li>在执行遍历的对象之后，是圆括号中的关键字if和条件表达式，目前，这个条件表达式只是用做过滤迭代的值。</li>
<li>在关键字for之前是expression，可以认为这个表达式是循环体</li>
</ul>
<h3 id="10-将数组推导中的方括号替换成圆括号，它就成了一个生成器表达式。生成器表达式和数组推导非常类似-两者在圆括号内的语法几乎完全一样-，只是它的返回值是一个生成器对象，而不是一个数组。和数组推导相比，使用生成器表达式的好处是可以惰性求值，只有在需要的时候求值而不是每次都计算求值，这种特性可以应用于潜在的无穷序列。使用生成器表达式而不用数组也有不足之处，生成器只支持对值的顺序存取而不是随机存取。"><a href="#10-将数组推导中的方括号替换成圆括号，它就成了一个生成器表达式。生成器表达式和数组推导非常类似-两者在圆括号内的语法几乎完全一样-，只是它的返回值是一个生成器对象，而不是一个数组。和数组推导相比，使用生成器表达式的好处是可以惰性求值，只有在需要的时候求值而不是每次都计算求值，这种特性可以应用于潜在的无穷序列。使用生成器表达式而不用数组也有不足之处，生成器只支持对值的顺序存取而不是随机存取。" class="headerlink" title="10.将数组推导中的方括号替换成圆括号，它就成了一个生成器表达式。生成器表达式和数组推导非常类似(两者在圆括号内的语法几乎完全一样)，只是它的返回值是一个生成器对象，而不是一个数组。和数组推导相比，使用生成器表达式的好处是可以惰性求值，只有在需要的时候求值而不是每次都计算求值，这种特性可以应用于潜在的无穷序列。使用生成器表达式而不用数组也有不足之处，生成器只支持对值的顺序存取而不是随机存取。"></a>10.将数组推导中的方括号替换成圆括号，它就成了一个生成器表达式。生成器表达式和数组推导非常类似(两者在圆括号内的语法几乎完全一样)，只是它的返回值是一个生成器对象，而不是一个数组。和数组推导相比，使用生成器表达式的好处是可以惰性求值，只有在需要的时候求值而不是每次都计算求值，这种特性可以应用于潜在的无穷序列。使用生成器表达式而不用数组也有不足之处，生成器只支持对值的顺序存取而不是随机存取。</h3><h3 id="11-try-catch语句已经可以使用多catch从句，在catch从句的参数中加入关键字if以及一个条件判断表达式。当产生一个异常时，程序将会尝试依次执行每一条catch从句。catch从句中的命名参数即是这个异常，执行到catch的时候会计算它的条件表达式。如果条件表达式计算结果为true，则判断当前catch从句中的逻辑，同时跳过其他的catch从句。如果catch从句中没有条件表达式，程序就会假设它包含一个if-true的条件，如果它之前的catch从句都没有触发，那么这条catch语句一定会执行。如果所有的catch从句都包含条件，但没有一个条件是true，那么程序会向上抛出这个未捕获的异常。"><a href="#11-try-catch语句已经可以使用多catch从句，在catch从句的参数中加入关键字if以及一个条件判断表达式。当产生一个异常时，程序将会尝试依次执行每一条catch从句。catch从句中的命名参数即是这个异常，执行到catch的时候会计算它的条件表达式。如果条件表达式计算结果为true，则判断当前catch从句中的逻辑，同时跳过其他的catch从句。如果catch从句中没有条件表达式，程序就会假设它包含一个if-true的条件，如果它之前的catch从句都没有触发，那么这条catch语句一定会执行。如果所有的catch从句都包含条件，但没有一个条件是true，那么程序会向上抛出这个未捕获的异常。" class="headerlink" title="11.try/catch语句已经可以使用多catch从句，在catch从句的参数中加入关键字if以及一个条件判断表达式。当产生一个异常时，程序将会尝试依次执行每一条catch从句。catch从句中的命名参数即是这个异常，执行到catch的时候会计算它的条件表达式。如果条件表达式计算结果为true，则判断当前catch从句中的逻辑，同时跳过其他的catch从句。如果catch从句中没有条件表达式，程序就会假设它包含一个if true的条件，如果它之前的catch从句都没有触发，那么这条catch语句一定会执行。如果所有的catch从句都包含条件，但没有一个条件是true，那么程序会向上抛出这个未捕获的异常。"></a>11.try/catch语句已经可以使用多catch从句，在catch从句的参数中加入关键字if以及一个条件判断表达式。当产生一个异常时，程序将会尝试依次执行每一条catch从句。catch从句中的命名参数即是这个异常，执行到catch的时候会计算它的条件表达式。如果条件表达式计算结果为true，则判断当前catch从句中的逻辑，同时跳过其他的catch从句。如果catch从句中没有条件表达式，程序就会假设它包含一个if true的条件，如果它之前的catch从句都没有触发，那么这条catch语句一定会执行。如果所有的catch从句都包含条件，但没有一个条件是true，那么程序会向上抛出这个未捕获的异常。</h3>
    </div>

    
    
    
        <div class="reward-container">
  <div>您的支持是我最大的动力</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weixin.png" alt="丁可 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/zhifubao.png" alt="丁可 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>丁可
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2021/02/26/JavaScriptfour/" title="学习JavaScript权威指南第四天">http://yoursite.com/2021/02/26/JavaScriptfour/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/25/JavaScriptthree/" rel="prev" title="学习JavaScript权威指南第三天">
      <i class="fa fa-chevron-left"></i> 学习JavaScript权威指南第三天
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
      <div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
</div>

    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MTEwOC8yNzU4OQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#学习JavaScript权威指南第四天"><span class="nav-text">学习JavaScript权威指南第四天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-类和模块"><span class="nav-text">第九章 类和模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-类的特性有封装、继承和多态。"><span class="nav-text">1.类的特性有封装、继承和多态。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。"><span class="nav-text">2.构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。"><span class="nav-text">3.初始化对象的状态的构造函数不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。"><span class="nav-text">4.在JavaScript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-JavaScript中基于原型的继承机制是动态的-对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象。"><span class="nav-text">5.JavaScript中基于原型的继承机制是动态的:对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-instanceof运算符和isPrototypeOf-方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的Web应用中兼容性不佳。"><span class="nav-text">6.instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的Web应用中兼容性不佳。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法工作的-比如在浏览器窗口的多个框架子页面中-。同样，在JavaScript中也并非所有的对象都包含constructor属性。"><span class="nav-text">7.使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法工作的(比如在浏览器窗口的多个框架子页面中)。同样，在JavaScript中也并非所有的对象都包含constructor属性。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些JavaScript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的JavaScript实现来说，可以将函数转换为字符串，然后从中提取出函数名。这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题-并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。"><span class="nav-text">8.一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些JavaScript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的JavaScript实现来说，可以将函数转换为字符串，然后从中提取出函数名。这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题:并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-按照鸭式辩型的理念定义了quacks-函数。quacks-用以检查一个对象-第一个实参-是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。关于quacks-函数还有另一个问题需要注意，就是它不能应用于内置类。比如，不能通过quacks-o，Array-来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks-中的for-in循环无法遍历到它们-注意，在ECMAScript-5中有一个补救办法，就是使用Object-getOwnPropertyName"><span class="nav-text">9.按照鸭式辩型的理念定义了quacks()函数。quacks()用以检查一个对象(第一个实参)是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。关于quacks()函数还有另一个问题需要注意，就是它不能应用于内置类。比如，不能通过quacks(o，Array)来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks()中的for&#x2F;in循环无法遍历到它们(注意，在ECMAScript 5中有一个补救办法，就是使用Object.getOwnPropertyName())</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等。或者比较它们的顺序。这里所说的”相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。如果将对象用于JavaScript的关系比较运算符，比如”-lt-”和”-lt-”，JavaScript会首先调用对象的valueOf-，如果这个方法返回一个原始值，则直接比较原始值。"><span class="nav-text">10.JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等。或者比较它们的顺序。这里所说的”相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。如果将对象用于JavaScript的关系比较运算符，比如”&lt;”和”&lt;&#x3D;”，JavaScript会首先调用对象的valueOf()，如果这个方法返回一个原始值，则直接比较原始值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-我们可以通过将变量-或参数-闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数-因此这个函数可以访问构造函数内部的参数和变量-，并将这个函数赋值给新创建对象的属性。但需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢。"><span class="nav-text">11.我们可以通过将变量(或参数)闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数(因此这个函数可以访问构造函数内部的参数和变量)，并将这个函数赋值给新创建对象的属性。但需要注意的是，这种封装技术造成了更多系统开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-通过重载构造函数可以让它根据传入参数的不同来执行不同的初始化方法。"><span class="nav-text">12.通过重载构造函数可以让它根据传入参数的不同来执行不同的初始化方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Object-defineProperty-和Object-defineProperties-可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。"><span class="nav-text">13.Object.defineProperty()和Object.defineProperties()可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-使用Object-create-创建对象时传入了参数null，这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用in运算符，而不须使用hasOwnProperty-方法。"><span class="nav-text">14.使用Object.create()创建对象时传入了参数null，这个创建的对象没有任何继承任何成员。这个对象用来存储集合的成员，同时，这个对象没有原型，这样我们就能对它直接使用in运算符，而不须使用hasOwnProperty()方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来-可以通过全局变量引用-，而不是定义全局函数和变量。"><span class="nav-text">15.在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来(可以通过全局变量引用)，而不是定义全局函数和变量。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十章-正则表达式的模式匹配"><span class="nav-text">第十章 正则表达式的模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript-5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。"><span class="nav-text">1.一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。另外，可以通过”-”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。"><span class="nav-text">2.将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。另外，可以通过”^”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-匹配重复字符是尽可能多地匹配，而且允许后续地正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在待匹配的字符后跟随一个问好即可。因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。"><span class="nav-text">3.匹配重复字符是尽可能多地匹配，而且允许后续地正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只需在待匹配的字符后跟随一个问好即可。因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用”-””-””-”或者”-”等来对单元内的项进行处理。圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。正则表达式不允许使用双引号括起的内容中有单引号，反之亦然。"><span class="nav-text">4.注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样用”|””*””+”或者”?”等来对单元内的项进行处理。圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。正则表达式不允许使用双引号括起的内容中有单引号，反之亦然。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-正则表达式中的多个元素才能够匹配字符串的一个字符。还有一些正则表达式的元素匹配的是字符串之间的位置，而不是实际的字符。-b匹配一个单词的边界，像-b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是-，它用来匹配字符串的开始，锚元素-用以匹配字符串的结束。"><span class="nav-text">5.正则表达式中的多个元素才能够匹配字符串的一个字符。还有一些正则表达式的元素匹配的是字符串之间的位置，而不是实际的字符。\b匹配一个单词的边界，像\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-String支持4种使用正则表达式的方法。"><span class="nav-text">6.String支持4种使用正则表达式的方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-需要注意的是，不论是字符串直接量还是正则表达式，都使用”-quot-字符作为转义字符的前缀，因此当给RegExp-传入一个字符串表述的正则表达式时，必须将”-quot-替换成”-“。RegExp-构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。"><span class="nav-text">7.需要注意的是，不论是字符串直接量还是正则表达式，都使用”&quot;字符作为转义字符的前缀，因此当给RegExp()传入一个字符串表述的正则表达式时，必须将”&quot;替换成”\“。RegExp()构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读-写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置。"><span class="nav-text">8.每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读布尔值，用以说明正则表达式是否带有修饰符i。属性multiline是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读&#x2F;写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-RegExp对象定义了两个用于执行模式匹配操作的方法。"><span class="nav-text">9.RegExp对象定义了两个用于执行模式匹配操作的方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-在ECMAScript-5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新的RegExp对象具有各自的lastIndex属性，这势必会大大减少”残留”lastIndex对程序造成的意外影响。"><span class="nav-text">10.在ECMAScript 5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新的RegExp对象具有各自的lastIndex属性，这势必会大大减少”残留”lastIndex对程序造成的意外影响。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十一章-JavaScript的子集和扩展"><span class="nav-text">第十一章 JavaScript的子集和扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。"><span class="nav-text">1.大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-解构赋值右侧的数组所包含的元素不必和左侧的变量一一对应，左侧多余的变量的赋值为undefined，而右侧多余的值则会忽略。左侧的变量列表可以包含连续的逗号用以跳过右侧对应的值。整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。因此，可以这样写”链式”解构赋值。"><span class="nav-text">2.解构赋值右侧的数组所包含的元素不必和左侧的变量一一对应，左侧多余的变量的赋值为undefined，而右侧多余的值则会忽略。左侧的变量列表可以包含连续的逗号用以跳过右侧对应的值。整个解构赋值运算的返回值是右侧的整个数据结构，而不是从中提取出来的某个值。因此，可以这样写”链式”解构赋值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-for-each循环和for-in循环非常类似。但for-each并不是遍历对象的属性，而是遍历属性的值。注意，for-each循环并不仅仅针对数组本身的元素进行遍历，它也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。"><span class="nav-text">3.for&#x2F;each循环和for&#x2F;in循环非常类似。但for&#x2F;each并不是遍历对象的属性，而是遍历属性的值。注意，for&#x2F;each循环并不仅仅针对数组本身的元素进行遍历，它也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-如果出于某种考虑，你想从可迭代的对象中显式获得一个迭代器对象。只需调用Iterator-函数即可-这个函数是定义在JavaScript1-7中的全局函数-。如果这个函数的参数是一个可迭代的对象，那么它将返回这个对象的iterator-方法的调用结果，从而保持代码整洁干净。如果给Iterator-函数传入第二个参数，这个参数也会参与iterator-方法的调用。"><span class="nav-text">4.如果出于某种考虑，你想从可迭代的对象中显式获得一个迭代器对象。只需调用Iterator()函数即可(这个函数是定义在JavaScript1.7中的全局函数)。如果这个函数的参数是一个可迭代的对象，那么它将返回这个对象的iterator()方法的调用结果，从而保持代码整洁干净。如果给Iterator()函数传入第二个参数，这个参数也会参与iterator()方法的调用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Iterator-函数返回的迭代器还有两个重要的特性。第一，它只对自有属性进行遍历而忽略继承的属性，通常我们希望是这个样子。第二，如果给Iterator-传入第二个参数true，返回的迭代器只对属性名进行遍历，而忽略属性值。"><span class="nav-text">5.Iterator()函数返回的迭代器还有两个重要的特性。第一，它只对自有属性进行遍历而忽略继承的属性，通常我们希望是这个样子。第二，如果给Iterator()传入第二个参数true，返回的迭代器只对属性名进行遍历，而忽略属性值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-生成器函数通过yield返回值。这些函数中可以使用return来终止函数的执行而不带任何返回值，但不能使用return来返回一个值。除了使用yield，对return的使用限制也使生成器函数更明显地区别于普通函数。然而和普通的函数一样，生成器函数也通过关键字function声明，typeof运算符返回”function”，并可以从Function-prototype继承属性和方法。但对生成器函数的调用却和普通函数完全不一样，不是执行生成器函数的函数体，而是返回一个生成器对象。"><span class="nav-text">6.生成器函数通过yield返回值。这些函数中可以使用return来终止函数的执行而不带任何返回值，但不能使用return来返回一个值。除了使用yield，对return的使用限制也使生成器函数更明显地区别于普通函数。然而和普通的函数一样，生成器函数也通过关键字function声明，typeof运算符返回”function”，并可以从Function.prototype继承属性和方法。但对生成器函数的调用却和普通函数完全不一样，不是执行生成器函数的函数体，而是返回一个生成器对象。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-当调用了生成器的close-方法时，和它相关的生成器函数就会终止执行，就像在函数运行挂起的位置执行一条return语句。如果当前挂起位置在一个或者多个try语句块中，那么将首先运行finally从句，再执行close-返回。close-没有返回值，但如果finally语句块产生了异常，这个异常则会传播给close-。"><span class="nav-text">7.当调用了生成器的close()方法时，和它相关的生成器函数就会终止执行，就像在函数运行挂起的位置执行一条return语句。如果当前挂起位置在一个或者多个try语句块中，那么将首先运行finally从句，再执行close()返回。close()没有返回值，但如果finally语句块产生了异常，这个异常则会传播给close()。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-每一个生成器都有一个send-方法，后者用来重启生成器的执行，就像next-方法一样。和next-不同的是，send-可以带一个参数，这个参数的值就成为yield表达式的值-多数生成器函数是不会接收额外的输入的，关键字yield看起来像一条语句。"><span class="nav-text">8.每一个生成器都有一个send()方法，后者用来重启生成器的执行，就像next()方法一样。和next()不同的是，send()可以带一个参数，这个参数的值就成为yield表达式的值(多数生成器函数是不会接收额外的输入的，关键字yield看起来像一条语句。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-数组推导是从Python中借用过来的一个概念。它是一种利用另外一个数组或可迭代对象来初始化数组元素的技术。数组推导包含三个部分"><span class="nav-text">9.数组推导是从Python中借用过来的一个概念。它是一种利用另外一个数组或可迭代对象来初始化数组元素的技术。数组推导包含三个部分:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-将数组推导中的方括号替换成圆括号，它就成了一个生成器表达式。生成器表达式和数组推导非常类似-两者在圆括号内的语法几乎完全一样-，只是它的返回值是一个生成器对象，而不是一个数组。和数组推导相比，使用生成器表达式的好处是可以惰性求值，只有在需要的时候求值而不是每次都计算求值，这种特性可以应用于潜在的无穷序列。使用生成器表达式而不用数组也有不足之处，生成器只支持对值的顺序存取而不是随机存取。"><span class="nav-text">10.将数组推导中的方括号替换成圆括号，它就成了一个生成器表达式。生成器表达式和数组推导非常类似(两者在圆括号内的语法几乎完全一样)，只是它的返回值是一个生成器对象，而不是一个数组。和数组推导相比，使用生成器表达式的好处是可以惰性求值，只有在需要的时候求值而不是每次都计算求值，这种特性可以应用于潜在的无穷序列。使用生成器表达式而不用数组也有不足之处，生成器只支持对值的顺序存取而不是随机存取。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-try-catch语句已经可以使用多catch从句，在catch从句的参数中加入关键字if以及一个条件判断表达式。当产生一个异常时，程序将会尝试依次执行每一条catch从句。catch从句中的命名参数即是这个异常，执行到catch的时候会计算它的条件表达式。如果条件表达式计算结果为true，则判断当前catch从句中的逻辑，同时跳过其他的catch从句。如果catch从句中没有条件表达式，程序就会假设它包含一个if-true的条件，如果它之前的catch从句都没有触发，那么这条catch语句一定会执行。如果所有的catch从句都包含条件，但没有一个条件是true，那么程序会向上抛出这个未捕获的异常。"><span class="nav-text">11.try&#x2F;catch语句已经可以使用多catch从句，在catch从句的参数中加入关键字if以及一个条件判断表达式。当产生一个异常时，程序将会尝试依次执行每一条catch从句。catch从句中的命名参数即是这个异常，执行到catch的时候会计算它的条件表达式。如果条件表达式计算结果为true，则判断当前catch从句中的逻辑，同时跳过其他的catch从句。如果catch从句中没有条件表达式，程序就会假设它包含一个if true的条件，如果它之前的catch从句都没有触发，那么这条catch语句一定会执行。如果所有的catch从句都包含条件，但没有一个条件是true，那么程序会向上抛出这个未捕获的异常。</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="丁可"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">丁可</p>
  <div class="site-description" itemprop="description">哪来的勇气我就是不灰心</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DK-frontend" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DK-frontend" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/504015629@qq.com" title="E-Mail → 504015629@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/DK159753" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;DK159753" rel="noopener" target="_blank"><i class="fab fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      <iframe allow="autoplay" frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1363973661&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">丁可</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">240k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:38</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共126.9k字</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>


